/*!
 * SVG path parser
 * version: 2018.05.10
 * author: dobrapyra
 * url: https://github.com/dobrapyra/SvgPathParser
 */
Object.keys||(Object.keys=function(t){if(t!==Object(t))throw new TypeError("Object.keys called on a non-object");var n,r=[];for(n in t)t.hasOwnProperty(n)&&r.push(n);return r}),Object.assign||(Object.assign=function(t){if(t!==Object(t))throw new TypeError("Object.assign called on a non-object");var n,r,e,s,i,o,a,c;for(n=Object(t),i=arguments.length,s=1;s<i;s++)if(r=arguments[s])for(a=(e=Object.keys(r)).length,o=0;o<a;o++)n[c=e[o]]=r[c];return n});var SvgPathParser=function(t){this.init(t)};Object.assign(SvgPathParser.prototype,{init:function(t){},parsePath:function(t){return t.tagName&&"path"===t.tagName?this.parse(t.getAttribute("d")):(console.warn("Wrong input, expected path element."),this.pointsArr=[],this)},parse:function(t){var n=t.split(/\s*z\s*/);console.log(n);for(var r=0,e=t.length;r<e;r++)t[r];return this.pointsArr=[],this},result:function(){return this.pointsArr},round:function(n){var r=this._roundVal;return this.pointsArr=this.pointsArr.map(function(t){return Object.assign(t,{x:r(x,n),y:r(y,n)})}),this},_roundVal:function(t,n){return Math.round(t*n)/n}});